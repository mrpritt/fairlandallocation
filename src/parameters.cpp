/*
* A genetic algorithm for fair land allocation
* Copyright (c) 2017 Alex Gliesch, Marcus Ritt, Mayron C. O. Moreira
*
* Permission is hereby granted, free of charge, to any person (the "Person")
* obtaining a copy of this software and associated documentation files (the
* "Software"), to deal in the Software, including the rights to use, copy, modify,
* merge, publish, distribute the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* 1. The above copyright notice and this permission notice shall be included in
*    all copies or substantial portions of the Software.
* 2. Under no circumstances shall the Person be permitted, allowed or authorized
*    to commercially exploit the Software.
* 3. Changes made to the original Software shall be labeled, demarcated or
*    otherwise identified and attributed to the Person.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
#include "parameters.h"
#include "proterra.h"
#include "random.h"
#include "statistics.h"
#include "util.h"
#include <boost/program_options.hpp>
#include <cassert>
#include <cstdio>
#include <ctime>
#include <iostream>

double prm::new_rate = 0.0;

string prm::desc_irace =
    "choose this option when tuning with irace; the program will "
    "output only an integer";
bool prm::irace = false;

string prm::desc_tourn =
    "size of tournament used to choose parents for crossover";
int prm::tournament_size = 3;

string prm::desc_brush = "size of brush that erases borders in the mutation "
                         "operator. when expanding the brush over a "
                         "border cell, only cells in the same lot are "
                         "expanded. this means 'brush_size' "
                         "cells will be expanded on both sides of the border; "
                         "so for instance if the brush size is "
                         "5, then the erased area will have a width of 10";
int prm::mutation_brush_size = 2;

string prm::desc_rest =
    "after this many of generations without improvement, the genetic algorhtm "
    "will restart with a random population";
int prm::restart = 100;

string prm::desc_gra =
    "when reconstructing the borders for the mutation operator, instead of "
    "assigning the best 'batch_size' cells at every step, we choose "
    "'batch_size' cells "
    "randomly among the best \alpha * batch_size elements. this should be a "
    "number greater "
    "than 1.0";
double prm::mutation_greedy_alpha = 4.0;

string prm::desc_cr =
    "ratio of solutions generated by crossover, in the new population";
double prm::crossover_ratio = 5.9;

string prm::desc_kr =
    "ratio of solutions in the new population that are selected from the best "
    "solutions of the previous population";
double prm::keep_ratio = 8.5;

string prm::desc_ps = "genetic algorithm's population size";
int prm::pop_size = 15;

string prm::desc_dm = "do not perform mutation";
bool prm::do_mutation = true;

string prm::desc_dc = "do not perform crossover";
bool prm::do_crossover = true;

string prm::desc_msr =
    "the maximum ratio of the area of the largest to the smallest lot";
int prm::maximum_size_ratio = 3;

string prm::desc_tl = "time limit (seconds)";
int prm::time_limit_seconds = 30;

string prm::desc_seed =
    "random seed. by default, a random random seed will be used";
ll prm::random_seed = -1;

string prm::desc_mgen =
    "the maximum number of generations the program is allowed to "
    "perform. by default, there is no limit";
int prm::max_generations = -1;

string prm::desc_naive =
    "if this option is set, a 'naive' algorithm will be used: "
    "lots originating from random seeds are expanded with BFS.";
bool prm::naive = false;

string prm::desc_png =
    "an image of the the best solution will be generated and saved in the "
    "specified filename";
string prm::png = "";

string prm::desc_si =
    "if this is set, the program will only output the visualization"
    " of the solution contained in the specified file";
string prm::solution_input = "";

string prm::desc_if = "input filename (.input file)";
string prm::instance_name = "";
string prm::input_filename = "";

string prm::desc_bat = "the constructive algorithm will assign this many cells "
                       "at each construction step";
int prm::batch_size = 256;

string prm::desc_nbs =
    "determines the neighbourhood of a cell: a neighbourhood of 4 means left, "
    "right, up and down; a neighbourhood of 8 also uses the diagonals";
int prm::neighborhood_size = 4;

namespace po = boost::program_options;
po::options_description desc("proterra");

template <typename T>
void add_opt(const string& opt, T* var, const string var_desc,
             bool required = false) {
  auto o2 = required ? po::value<T>(var)->required()
                     : po::value<T>(var)->default_value(*var);
  desc.add_options()(opt.c_str(), o2, var_desc.c_str());
}

void prm::parse_cmd_line(int argc, char** argv) {
  desc.add_options()("help", "show help menu");
  add_opt("batch-size", &batch_size, desc_bat);
  add_opt("in", &input_filename, desc_if, true);
  add_opt("neighbourhood", &neighborhood_size, desc_nbs);
  add_opt("solution", &solution_input, desc_si);
  add_opt("png", &png, desc_png);
  desc.add_options()("naive", desc_naive.c_str());
  add_opt("max-generations", &max_generations, desc_mgen);
  add_opt("seed", &random_seed, desc_seed);
  add_opt("time", &time_limit_seconds, desc_tl);
  add_opt("size-ratio", &maximum_size_ratio, desc_msr);
  desc.add_options()("no-crossover", desc_dc.c_str());
  desc.add_options()("no-mutation", desc_dm.c_str());
  add_opt("pop-size", &pop_size, desc_ps);
  add_opt("keep-ratio", &keep_ratio, desc_kr);
  add_opt("crossover-ratio", &crossover_ratio, desc_cr);
  add_opt("mutation-alpha", &mutation_greedy_alpha, desc_gra);
  add_opt("restart", &restart, desc_rest);
  add_opt("mutation-brush", &mutation_brush_size, desc_brush);
  add_opt("tournament-size", &tournament_size, desc_tourn);
  desc.add_options()("irace", desc_irace.c_str());

  po::variables_map vm;
  try {
    po::store(po::parse_command_line(argc, argv, desc), vm);
    if (vm.count("help")) {
      cout << desc << endl;
      exit(EXIT_SUCCESS);
    } else {
      po::notify(vm);
    }

    irace = vm.count("irace");
    naive = vm.count("naive");
    do_crossover = not vm.count("no-crossover");
    do_mutation = not vm.count("no-mutation");

    if (png.size() and png.find(".png") == string::npos) png += ".png";

    if (random_seed == -1)
      random_seed = rng.seed_unique();
    else
      rng.seed(random_seed);

    pr("--seed: {}\n", random_seed);

    if (max_generations == -1) max_generations = nl<int>::max();

    instance_name = input_filename;
    size_t i = instance_name.find(".input");
    if (i != string::npos)
      instance_name.erase(instance_name.begin() + i, instance_name.end());
    i = instance_name.find_last_of("/");
    if (i != string::npos)
      instance_name.erase(instance_name.begin(),
                          next(instance_name.begin() + i));
  } catch (po::error& e) {
    fmt::print("Error parsing command line: {}\n", e.what());
    cout << desc << endl;
    exit(EXIT_FAILURE);
  }
}
